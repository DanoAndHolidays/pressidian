# 1.1 计算机发展
## 1.1.1 计算机系统
### 软件
![[Pasted image 20251111195855.png]]
### 硬件
![[Pasted image 20251111200219.png]]
	
![[Pasted image 20251111200901.png]]
	
![[Pasted image 20251111201153.png]]
	
![[Pasted image 20251111201300.png]]
（此小节408大纲不考）
# 1.2 计算机结构
## 1.2.1 计算机硬件基本结构
### 早期冯诺依曼机
![[Pasted image 20251111202431.png]]
我们可以使用软件的方式实现乘法，而不需要专门去实现一个乘法运算单元

![[Pasted image 20251111202818.png]]
无论输入还是输出数据都要经过运算器，但本质运算器是用来处理数据而不是转运数据，这样的设计会降低效率

### 现代计算机结构
![[Pasted image 20251111203206.png]]

现代计算机以存储器为核心，运算器+控制器=CPU
![[Pasted image 20251111203538.png]]
## 1.2.2 硬件工作原理
### 主存储器（内存）
![[Pasted image 20251112160142.png]]
（在现代计算机中MAR与MDR被设计在CPU中）
### 运算器
![[Pasted image 20251112160427.png]]
### 控制器
![[Pasted image 20251112160737.png]]
![[Pasted image 20251112160758.png]]
### 计算机工作过程
![[Pasted image 20251112161613.png]]
![[Pasted image 20251112161923.png]]
![[Pasted image 20251112162203.png]]
![[Pasted image 20251112162318.png]]
![[Pasted image 20251112162407.png]]
## 1.2.3 计算机软件
### 软件分类
![[Pasted image 20251112163606.png]]
### 语言分类
![[Pasted image 20251112163458.png]]
### 软件硬件逻辑功能的等价性
我们可以使用软件的方式来实现乘法（使用加法），也可以使用专用的硬件来实现（成本高，但性能更好）
指令集体系结构（ISA）：用来定义一台计算机所支持的指令，以及每一条指令的用法与作用是什么，是软件与硬件之间的界限，在设计ISA时要同时考虑成本与效率问题
## 1.2.4 计算机系统的层次结构
![[Pasted image 20251112164735.png]]
## 1.2.5 计算机系统工作原理
![[Pasted image 20251112165233.png]]
## 1.2.6 计算机性能指标
### 存储器的性能指标
![[Pasted image 20251112165715.png]]
### CPU的性能指标
![[Pasted image 20251112170231.png]]
![[Pasted image 20251112170658.png]]
### 系统整体性能指标
![[Pasted image 20251112171029.png]]
我们可以使用基准程序来测试计算机的性能
# 2.1 数据的表示
## 2.1.1 进位计数制
![[Pasted image 20251112172818.png]]
基数：内个数码位所用到的符号的数量，r进制的基数为r
### 位权展开法（转为十进制）
![[Pasted image 20251112172942.png]]

![[Pasted image 20251112173120.png]]
### 二八十六进制互转
![[Pasted image 20251112173351.png]]

![[Pasted image 20251112173438.png]]
### 除基取余法（十进制转任意进制）
除二倒取余：
![[Pasted image 20251112174326.png]]
### 乘基取整法
乘二正取整：
![[Pasted image 20251112174629.png]]
0.2与0.3无法使用二进制精确的表示，是因为没有2^x的组合能够拼出这两个数，只能无限的接近，一般取到小数点第五位
### 真值与机器数
![[Pasted image 20251112174952.png]]
## 2.1.2 定点数的编码表示
### 无符号数
![[Pasted image 20251112175953.png]]
![[Pasted image 20251112180022.png]]
通常讨论无符号数时，只会讨论整数
### 有符号数
![[Pasted image 20251112180327.png]]
![[Pasted image 20251112183104.png]]
![[Pasted image 20251112182404.png]]
- 原码：
	![[Pasted image 20251112180910.png]]
	
	![[Pasted image 20251112181255.png]]
- 反码：与原码一一对应
	![[Pasted image 20251112181409.png]]
- 补码：
	![[Pasted image 20251112182058.png]]
	由[x]补求[-x]补：符号位与数值为全部取反，末尾再+1
	由补码求原码的快速运算：符号位不变，从右向左找到第一个“1”，将这个“1”左侧剩余的尾数取反，即可得到源码。用尾数取反+1也是一样的
- 移码：可以使用移码的值来比较真值的大小
	![[Pasted image 20251112182235.png]]
## 2.1.2 码的作用
![[Pasted image 20251113164652.png]]
在使用有符号数的原码进行运算的时候（+-），必须要考虑数的正负，否则计算的结果会有异常，我们可以使用模运算将两个数的减法变为加法
### 模运算
![[Pasted image 20251113165627.png]]

由于模运算的性质，实质上是将数分为不同的类，上例中分为12类，而在字长为8bit的计算机中，是将数分为了2^8 类，也就是8位的计算机会自动的进行mod2^8的操作：
![[Pasted image 20251113170453.png]]
补码，也就是原码的补数，通过这样的方式就能仅在ALU中实现加法操作
## 2.1.4 C语言中的类型转换
在计算机中，有符号定点整数通常是使用补码来表示的
![[Pasted image 20251113171927.png]]
### 零扩展与符号扩展
![[Pasted image 20251113172127.png]]

![[Pasted image 20251113173137.png]]
# 2.2 数据的运算
## 2.2.0 电路
优先级：非>与>或，有括号先算括号
![[Pasted image 20251113174907.png]]
### 基本逻辑运算
![[Pasted image 20251113173724.png]]

![[Pasted image 20251113173832.png]]

![[Pasted image 20251113173946.png]]
### 复合逻辑运算
![[Pasted image 20251113174129.png]]

![[Pasted image 20251113174212.png]]

![[Pasted image 20251113174453.png]]

![[Pasted image 20251113174832.png]]
### 多路选择器
![[Pasted image 20251113180449.png]]
### 三态门
![[Pasted image 20251113180552.png]]
## 2.2.1 加法器
### 串行进位的并行加法器
进位信息是串行产生的，只有后一位运算完，前一位才能得到稳定的结果，这也叫行波进位
![[Pasted image 20251113181258.png]]

![[Pasted image 20251113181417.png]]
### 并行进位的并行加法器
![[Pasted image 20251113181810.png]]
无论是串行还是并行，都可以封装为一个加法器，不必关心其内部
### 带有标志位的加法器
![[Pasted image 20251113182101.png]]
![[Pasted image 20251113182551.png]]
### 算数逻辑单元ALU
![[Pasted image 20251113183705.png]]

![[Pasted image 20251113183857.png]]

![[Pasted image 20251113185327.png]]
## 2.2.2 定点数的位移运算
### 逻辑移位（无符号整数）
![[Pasted image 20251113190330.png]]
![[Pasted image 20251113190415.png]]

![[Pasted image 20251113190519.png]]
### 算数移位（带符号整数 补码）
![[Pasted image 20251113190809.png]]
![[Pasted image 20251113190841.png]]

![[Pasted image 20251113191051.png]]
## 2.2.3 定点数的加减运算
![[Pasted image 20251113192650.png]]

这种方式实现很困难，一般使用补码：
![[Pasted image 20251113193326.png]]

只有同号的两个数相加才会溢出，异号的两个数的和只能比这两个数的绝对值更小，不可能溢出：
![[Pasted image 20251113193900.png]]
### 溢出判断
![[Pasted image 20251113194318.png]]

![[Pasted image 20251113194521.png]]

![[Pasted image 20251113194829.png]]
# 2.3 
## 